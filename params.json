{"name":"Spot","tagline":"DataMapper ORM for PHP with adapters for MySQL, PosgreSQL and DB2","body":"Spot PHP ORM+ODM\r\n----------------\r\nFor Relational Databases and MongoDB\r\n\r\n[![Build Status](https://www.travis-ci.org/brandonlamb/Spot.png?branch=master)](https://www.travis-ci.org/brandonlamb/Spot)\r\n\r\nConnecting to a Database\r\n========================\r\nThe `Spot\\Config` object stores and references database connections by name.\r\nCreate a new instance of `Spot\\Config` and add database connections created outside\r\nof Spot. This was a change to allow your app to create the raw PDO connection and\r\njust reuse this. A big complaint I have always had is pretty much every ORM/Model\r\nclass always wants to create this for you instead of being passed this connection.\r\n\r\n```\r\n// PostgreSQL\r\n$db = new Pdo('pgsql:host=localhost;dbname=jdoe', 'jdoe', 'mypass');\r\n\r\n$cfg = \\Spot\\Config::getInstance();\r\n$adapter = $cfg->addConnection('db', new \\Spot\\Adapter\\Pgsql($db));\r\n\r\n$adapter = $cfg->connection('db');\r\n```\r\n\r\nAccessing the Mapper\r\n====================\r\n\r\nSince Spot follows the DataMapper design pattern, you will need a mapper\r\ninstance for working with object Entities and database tables.\r\n\r\n```\r\n$mapper = new \\Spot\\Mapper($cfg);\r\n```\r\n\r\nSince you have to have access to your mapper anywhere you use the\r\ndatabase, most people create a helper method to create a mapper instance\r\nonce and then return the same instance when required again. Such a\r\nhelper method might look something like this:\r\n\r\n```\r\nfunction get_mapper() {\r\n    static $mapper;\r\n    if($mapper === null) {\r\n        $mapper = new \\Spot\\Mapper($cfg);\r\n    }\r\n    return $mapper;\r\n}\r\n```\r\n\r\nOr if you have a Registry class in your framework:\r\n\r\n```\r\n$registry = Registry::getInstance();\r\n$registry->set('mapper', $mapper);\r\n\r\n$mapper = Register::get('mapper');\r\n```\r\n\r\nOr using a Dependency Injection Container\r\n\r\n```\r\n$di->setShared('mapper', $mapper);\r\n\r\n$mapper = $di->getShared('mapper');\r\n```\r\n\r\nCreating Entities\r\n=================\r\n\r\nEntity classes can be named and namespaced however you want to set them\r\nup within your project structure. For the following examples, the\r\nEntities will just be prefixed with an `Entity` namespace for easy psr-0\r\ncompliant autoloading.\r\n\r\n```\r\nnamespace Entity;\r\n\r\nclass Post extends \\Spot\\Entity\r\n{\r\n    protected static $datasource = 'posts';\r\n\r\n    public static function fields()\r\n    {\r\n        return array(\r\n            'id' => array('type' => 'int', 'primary' => true, 'serial' => true),\r\n            'title' => array('type' => 'string', 'required' => true),\r\n            'body' => array('type' => 'text', 'required' => true),\r\n            'status' => array('type' => 'int', 'default' => 0, 'index' => true),\r\n            'date_created' => array('type' => 'datetime')\r\n        );\r\n    }\r\n\r\n    public static function relations()\r\n    {\r\n        return array(\r\n            // Each post entity 'hasMany' comment entites\r\n            'comments' => array(\r\n                'type' => 'HasMany',\r\n                'entity' => 'Entity_Post_Comment',\r\n                'where' => array('post_id' => ':entity.id'),\r\n                'order' => array('date_created' => 'ASC')\r\n            )\r\n        );\r\n    }\r\n}\r\n```\r\n\r\nAnother entity example of a model class inside an application's Model namespace.\r\nThis is the simplest definition, only defining the model's fields.\r\n\r\n```\r\n<?php\r\nnamespace Blog\\Model;\r\nuse \\Spot\\Entity;\r\n\r\nclass Game extends Entity\r\n{\r\n\tprotected static $datasource = 'game';\r\n\r\n\tpublic static function fields()\r\n\t{\r\n\t\treturn array(\r\n\t\t\t'id' => array('type' => 'int', 'primary' => true, 'serial' => true),\r\n\t\t\t'status_id' => array('type' => 'int', 'default' => 0, 'index' => true),\r\n\t\t\t'date_created' => array('type' => 'datetime', 'default' => date('Y-m-d h:m:i'), 'required' => true),\r\n\t\t\t'image_count' => array('type' => 'int', 'default' => 0, 'index' => true),\r\n\t\t\t'name' => array('type' => 'string', 'required' => true),\r\n\t\t\t'slug' => array('type' => 'string', 'required' => true),\r\n\t\t);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n### Built-in Field Types\r\n\r\nAll the basic field types are built-in with all the default\r\nfunctionality provided for you:\r\n\r\n * `string`\r\n * `int`\r\n * `float/double/decimal`\r\n * `boolean`\r\n * `text`\r\n * `date`\r\n * `datetime`\r\n * `timestamp`\r\n * `year`\r\n * `month`\r\n * `day`\r\n\r\n#### Registering Custom Field Types\r\n\r\nIf you want to register your own custom field type with custom\r\nfunctionality on get/set, have a look at the clases in the `Spot\\Type`\r\nnamespace, make your own, and register it in `Spot\\Config`:\r\n\r\n```\r\n$this->setTypeHandler('string', '\\Spot\\Type\\String');\r\n```\r\n\r\n### Relation Types\r\n\r\nEntity relation types are:\r\n\r\n * `HasOne`\r\n * `HasMany`\r\n * `HasManyThrough`\r\n\r\n\r\nFinders (Mapper)\r\n================\r\n\r\nThe main finders used most are `all` to return a collection of entities,\r\nand `first` or `get` to return a single entity matching the conditions.\r\n\r\n### all(entityName, [conditions])\r\n\r\nFind all `entityName` that matches the given conditions and return a\r\n`Spot\\Entity\\Collection` of loaded `Spot\\Entity` objects.\r\n```\r\n// Conditions can be the second argument\r\n$posts = $mapper->all('Entity\\Post', array('status' => 1));\r\n\r\n// Or chained using the returned `Spot\\Query` object - results identical to above\r\n$posts = $mapper->all('Entity\\Post')->where(array('status' => 1));\r\n\r\n// Or building up a query programmatically\r\n$posts = $mapper->all('Entity\\Post');\r\n$posts->where(array('date_created :gt', date('Y-m-d'));\r\n\r\n... // Do some checks\r\n\r\n$posts->limit(10);\r\n```\r\n\r\nSince a `Spot\\Query` object is returned, conditions and other statements\r\ncan be chained in any way or order you want. The query will be\r\nlazy-executed on interation or `count`, or manually by ending the chain with a\r\ncall to `execute()`.\r\n\r\n### first(entityName, [conditions])\r\n\r\nFind and return a single `Spot\\Entity` object that matches the criteria.\r\n```\r\n$post = $mapper->first('Entity\\Post', array('title' => \"Test Post\"));\r\n```\r\n\r\nIterating Over Results\r\n======================\r\n\r\n```\r\n// Fetch mapper from DI container\r\n$mapper = $di->getShared('mapper');\r\n\r\n// Get Query object to add constraints\r\n$posts = $mapper->all('Entity\\Posts');\r\n\r\n// Find posts where the commenter's user_id is 123\r\n$posts->where(array('user_id :eq', 123));\r\n\r\n// Only get 10 results\r\n$limit = (int) $_POST['limit'];\r\n$posts->limit($limit);\r\n\r\n// Loop over results\r\nforeach ($posts as $post) {\r\n\techo \"Title: \" . $post->title . \"<br>\";\r\n\techo \"Created: \" . $post->date_created . \"<br>\";\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}